/**
 * 自定义适配器
 * 支持灵活的输出配置: 文件/目录、文件过滤、源组织等
 */

import * as path from 'path';
import * as vscode from 'vscode';

import type { CustomAdapterConfig } from '../types/config';
import type { ParsedRule } from '../types/rules';
import { safeWriteFile } from '../utils/fileSystem';
import { Logger } from '../utils/logger';
import { BaseAdapter, GeneratedConfig } from './AIToolAdapter';

/**
 * 自定义适配器
 * 根据配置生成文件或目录结构
 */
export class CustomAdapter extends BaseAdapter {
  public readonly name: string;
  public readonly enabled: boolean;
  private readonly config: CustomAdapterConfig;

  constructor(config: CustomAdapterConfig) {
    super();
    this.config = config;
    this.name = config.name;
    this.enabled = config.enabled;
  }

  /**
   * 获取配置文件路径
   */
  public getFilePath(): string {
    return this.config.outputPath;
  }

  /**
   * 生成输出配置
   */
  public async generate(rules: ParsedRule[]): Promise<GeneratedConfig> {
    try {
      Logger.info(`Generating custom adapter output: ${this.config.id}`, {
        ruleCount: rules.length,
        outputType: this.config.outputType,
      });

      // 过滤规则
      const filteredRules = this.filterRules(rules);
      Logger.debug(`Filtered rules: ${filteredRules.length}/${rules.length}`);

      if (filteredRules.length === 0) {
        Logger.warn(`No rules match filter for adapter: ${this.config.id}`);
      }

      // 根据输出类型生成
      if (this.config.outputType === 'file') {
        return await this.generateFile(filteredRules);
      } else {
        return await this.generateDirectory(filteredRules);
      }
    } catch (error) {
      Logger.error(`Failed to generate custom adapter output: ${this.config.id}`, error as Error);
      throw error;
    }
  }

  /**
   * 过滤规则
   * 根据文件后缀过滤
   * @param rules 所有规则
   * @returns 过滤后的规则列表
   */
  private filterRules(rules: ParsedRule[]): ParsedRule[] {
    // 未配置过滤规则，同步所有文件(不过滤)
    if (!this.config.fileExtensions || this.config.fileExtensions.length === 0) {
      return rules;
    }

    // 根据文件后缀过滤
    return rules.filter((rule) => {
      // 检查规则的源文件是否匹配任一后缀
      if (!rule.filePath) {
        return true; // 没有源文件信息，保留
      }
      return this.config.fileExtensions!.some((ext) => rule.filePath.endsWith(ext));
    });
  }

  /**
   * @description 生成单个文件输出
   * @return default {auto}
   */
  private async generateFile(rules: ParsedRule[]): Promise<GeneratedConfig> {
    const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (!workspaceRoot) {
      throw new Error('No workspace folder found');
    }

    // 按优先级排序
    const sortedRules = this.sortByPriority(rules);

    // 生成内容
    const content = this.generateFileContent(sortedRules);

    // 写入文件
    const absolutePath = path.join(workspaceRoot, this.config.outputPath);
    await safeWriteFile(absolutePath, content);

    Logger.info(`Generated file: ${this.config.outputPath}`, {
      ruleCount: rules.length,
      contentLength: content.length,
    });

    return {
      filePath: this.config.outputPath,
      content,
      generatedAt: new Date(),
      ruleCount: rules.length,
    };
  }

  /**
   * @description 生成文件内容
   * @return default {string}
   * @param rules {ParsedRule[]}
   */
  private generateFileContent(rules: ParsedRule[]): string {
    const lines: string[] = [];

    // 添加元数据
    lines.push(this.generateMetadata(rules.length));

    // 添加标题
    lines.push(`# ${this.config.name}\n`);
    lines.push('> This file is automatically generated by Turbo AI Rules extension.');
    lines.push('> Do not edit manually - changes will be overwritten on next sync.\n');

    // 添加规则
    for (const rule of rules) {
      lines.push(`## ${rule.title}\n`);

      // 添加元数据信息
      if (rule.metadata.priority) {
        lines.push(`**Priority:** ${rule.metadata.priority}\n`);
      }

      if (rule.metadata.tags && rule.metadata.tags.length > 0) {
        lines.push(`**Tags:** ${rule.metadata.tags.join(', ')}\n`);
      }

      if (rule.sourceId) {
        lines.push(`**Source:** ${rule.sourceId}\n`);
      }

      // 添加规则内容
      lines.push(rule.content);
      lines.push('\n---\n');
    }

    return lines.join('\n');
  }

  /**
   * 生成目录结构输出
   */
  private async generateDirectory(rules: ParsedRule[]): Promise<GeneratedConfig> {
    const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (!workspaceRoot) {
      throw new Error('No workspace folder found');
    }

    const files: Map<string, string> = new Map();
    const organizeBySource = this.config.organizeBySource ?? true;

    if (organizeBySource) {
      // 按源 ID 组织
      await this.generateBySource(rules, workspaceRoot, files);
    } else {
      // 平铺结构
      await this.generateFlat(rules, workspaceRoot, files);
    }

    // 生成索引文件
    let indexContent = '';
    let indexPath = '';
    if (this.config.generateIndex ?? true) {
      indexContent = this.generateDirectoryIndex(rules, organizeBySource);
      const indexFileName = this.config.indexFileName || 'index.md';
      indexPath = path.join(this.config.outputPath, indexFileName);
      const indexAbsolutePath = path.join(workspaceRoot, indexPath);
      await safeWriteFile(indexAbsolutePath, indexContent);
    }

    Logger.info(`Generated directory: ${this.config.outputPath}`, {
      fileCount: files.size,
      ruleCount: rules.length,
    });

    return {
      filePath: indexPath || this.config.outputPath,
      content: indexContent,
      generatedAt: new Date(),
      ruleCount: rules.length,
    };
  }

  /**
   * 按源 ID 组织文件
   */
  private async generateBySource(
    rules: ParsedRule[],
    workspaceRoot: string,
    files: Map<string, string>,
  ): Promise<void> {
    // 按源 ID 分组
    const rulesBySource = new Map<string, ParsedRule[]>();
    for (const rule of rules) {
      const sourceRules = rulesBySource.get(rule.sourceId) || [];
      sourceRules.push(rule);
      rulesBySource.set(rule.sourceId, sourceRules);
    }

    // 为每个源生成文件
    for (const [sourceId, sourceRules] of rulesBySource) {
      for (const rule of sourceRules) {
        const relativePath = path.join(this.config.outputPath, sourceId, `${rule.id}.md`);
        const absolutePath = path.join(workspaceRoot, relativePath);
        const content = `# ${rule.title}\n\n${rule.content}`;

        await safeWriteFile(absolutePath, content);
        files.set(relativePath, content);
        Logger.debug(`Written rule file: ${relativePath}`);
      }
    }
  }

  /**
   * 平铺结构(不按源组织)
   */
  private async generateFlat(
    rules: ParsedRule[],
    workspaceRoot: string,
    files: Map<string, string>,
  ): Promise<void> {
    for (const rule of rules) {
      // 使用 sourceId-ruleId 作为文件名避免冲突
      const fileName = `${rule.sourceId}-${rule.id}.md`;
      const relativePath = path.join(this.config.outputPath, fileName);
      const absolutePath = path.join(workspaceRoot, relativePath);
      const content = `# ${rule.title}\n\n${rule.content}`;

      await safeWriteFile(absolutePath, content);
      files.set(relativePath, content);
      Logger.debug(`Written rule file: ${relativePath}`);
    }
  }

  /**
   * 生成目录索引
   */
  private generateDirectoryIndex(rules: ParsedRule[], organizeBySource: boolean): string {
    const lines: string[] = [];

    lines.push(`# ${this.config.name}\n`);
    lines.push(this.generateMetadata(rules.length));

    if (organizeBySource) {
      // 按源分组显示
      const rulesBySource = new Map<string, ParsedRule[]>();
      for (const rule of rules) {
        const sourceRules = rulesBySource.get(rule.sourceId) || [];
        sourceRules.push(rule);
        rulesBySource.set(rule.sourceId, sourceRules);
      }

      for (const [sourceId, sourceRules] of rulesBySource) {
        lines.push(`## Source: ${sourceId}\n`);
        lines.push(`Total rules: ${sourceRules.length}\n`);

        for (const rule of sourceRules) {
          lines.push(`- [${rule.title}](./${sourceId}/${rule.id}.md)`);
        }

        lines.push('');
      }
    } else {
      // 平铺列表
      lines.push(`## All Rules\n`);
      lines.push(`Total rules: ${rules.length}\n`);

      for (const rule of rules) {
        const fileName = `${rule.sourceId}-${rule.id}.md`;
        lines.push(`- [${rule.title}](./${fileName}) *(from ${rule.sourceId})*`);
      }
    }

    return lines.join('\n');
  }
}
