/**
 * Cursor AI 适配器
 * 生成 .cursorrules 文件
 */

import type { ParsedRule } from '../types/rules';
import { Logger } from '../utils/logger';
import type { GeneratedConfig } from './AIToolAdapter';
import { BaseAdapter } from './AIToolAdapter';

/**
 * Cursor AI 适配器
 *
 * Cursor 使用 .cursorrules 文件，格式为纯 Markdown
 * 规则按优先级排序，高优先级规则放在前面
 */
export class CursorAdapter extends BaseAdapter {
  readonly name = 'Cursor';
  readonly enabled: boolean;

  constructor(enabled: boolean = true) {
    super();
    this.enabled = enabled;
  }

  /**
   * 生成 .cursorrules 文件内容
   */
  async generate(rules: ParsedRule[]): Promise<GeneratedConfig> {
    Logger.info('Generating Cursor configuration', { ruleCount: rules.length });

    if (rules.length === 0) {
      Logger.warn('No rules to generate for Cursor');
      return {
        filePath: this.getFilePath(),
        content: this.generateEmptyConfig(),
        generatedAt: new Date(),
        ruleCount: 0,
      };
    }

    // 按优先级排序
    const sortedRules = this.sortByPriority(rules);

    // 生成内容
    let content = '';

    // 添加元数据注释
    content += this.generateMetadata(rules.length);

    // 添加标题
    content += '# AI Coding Rules for Cursor\n\n';
    content += '> This file is automatically generated by Turbo AI Rules extension.\n';
    content += '> Do not edit manually - changes will be overwritten on next sync.\n\n';

    // 添加目录（Table of Contents）以便快速导航
    content += this.generateTableOfContents(sortedRules);

    // 添加规则
    content += this.formatRulesForCursor(sortedRules);

    Logger.info('Cursor configuration generated', {
      ruleCount: rules.length,
      contentLength: content.length,
    });

    return {
      filePath: this.getFilePath(),
      content,
      generatedAt: new Date(),
      ruleCount: rules.length,
    };
  }

  /**
   * 格式化规则为 Cursor 格式
   */
  private generateTableOfContents(rules: ParsedRule[]): string {
    if (!rules || rules.length === 0) return '';

    let toc = '## Table of Contents\n\n';

    for (const rule of rules) {
      const anchor = rule.title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/(^-|-$)/g, '');
      toc += `- [${rule.title}](#${anchor})\n`;
    }

    toc += '\n---\n\n';
    return toc;
  }

  private formatRulesForCursor(rules: ParsedRule[]): string {
    return rules
      .map((rule) => {
        let section = `## ${rule.title}\n\n`;

        // 基础元数据（优先级/标签/来源/文件/作者/版本）
        const metaParts: string[] = [];
        if (rule.metadata.priority) metaParts.push(`**Priority:** ${rule.metadata.priority}`);
        if (rule.metadata.tags && rule.metadata.tags.length > 0)
          metaParts.push(`**Tags:** ${rule.metadata.tags.join(', ')}`);
        if (rule.sourceId) metaParts.push(`**Source:** ${rule.sourceId}`);
        if (rule.filePath) metaParts.push(`**File:** ${rule.filePath}`);
        if (rule.metadata.author) metaParts.push(`**Author:** ${rule.metadata.author}`);
        if (rule.metadata.version) metaParts.push(`**Version:** ${rule.metadata.version}`);

        if (metaParts.length > 0) {
          section += metaParts.join(' | ') + '\n\n';
        }

        // 添加规则内容
        section += `${rule.content.trim()}\n`;

        return section;
      })
      .join('\n---\n\n');
  }

  /**
   * 生成空配置
   */
  private generateEmptyConfig(): string {
    return (
      this.generateMetadata(0) + '# AI Coding Rules for Cursor\n\n' + '> No rules configured yet.\n'
    );
  }

  /**
   * 验证 .cursorrules 文件
   */
  validate(content: string): boolean {
    // Cursor 的配置文件是纯 Markdown，只需检查非空
    if (!super.validate(content)) {
      return false;
    }

    // 可以添加更多验证逻辑，例如检查是否包含标题
    return content.includes('# ');
  }

  /**
   * 获取文件路径
   */
  getFilePath(): string {
    return '.cursorrules';
  }
}
