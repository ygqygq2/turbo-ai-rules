/**
 * GitHub Copilot é€‚é…å™¨
 * ç”Ÿæˆ .github/.copilot-instructions.md æ–‡ä»¶
 */

import type { ParsedRule } from '../types/rules';
import { Logger } from '../utils/logger';
import type { GeneratedConfig } from './AIToolAdapter';
import { BaseAdapter } from './AIToolAdapter';

/**
 * GitHub Copilot é€‚é…å™¨
 *
 * GitHub Copilot ä½¿ç”¨ .github/.copilot-instructions.md æ–‡ä»¶
 * æ”¯æŒæ›´ç»“æ„åŒ–çš„ Markdown æ ¼å¼ï¼Œå¯ä»¥åŒ…å«ä»£ç ç¤ºä¾‹
 */
export class CopilotAdapter extends BaseAdapter {
  readonly name = 'GitHub Copilot';
  readonly enabled: boolean;

  constructor(enabled: boolean = true) {
    super();
    this.enabled = enabled;
  }

  /**
   * ç”Ÿæˆ .github/.copilot-instructions.md æ–‡ä»¶å†…å®¹
   */
  async generate(rules: ParsedRule[]): Promise<GeneratedConfig> {
    Logger.info('Generating GitHub Copilot configuration', { ruleCount: rules.length });

    if (rules.length === 0) {
      Logger.warn('No rules to generate for GitHub Copilot');
      return {
        filePath: this.getFilePath(),
        content: this.generateEmptyConfig(),
        generatedAt: new Date(),
        ruleCount: 0,
      };
    }

    // æŒ‰ä¼˜å…ˆçº§æ’åº
    const sortedRules = this.sortByPriority(rules);

    // æŒ‰æ ‡ç­¾åˆ†ç»„
    const groupedByTag = this.groupByTag(sortedRules);

    // ç”Ÿæˆå†…å®¹
    let content = '';

    // æ·»åŠ å…ƒæ•°æ®æ³¨é‡Š
    content += this.generateMetadata(rules.length);

    // æ·»åŠ æ ‡é¢˜å’Œè¯´æ˜
    content += '# GitHub Copilot Instructions\n\n';
    content += '> This file provides coding guidelines and rules for GitHub Copilot.\n';
    content += '> Generated by Turbo AI Rules extension.\n\n';

    // æ·»åŠ ç›®å½•
    content += this.generateTableOfContents(groupedByTag);

    // æŒ‰æ ‡ç­¾æ·»åŠ è§„åˆ™
    content += this.formatRulesByTag(groupedByTag);

    Logger.info('GitHub Copilot configuration generated', {
      ruleCount: rules.length,
      tagCount: groupedByTag.size,
      contentLength: content.length,
    });

    return {
      filePath: this.getFilePath(),
      content,
      generatedAt: new Date(),
      ruleCount: rules.length,
    };
  }

  /**
   * ç”Ÿæˆç›®å½•
   */
  private generateTableOfContents(groupedByTag: Map<string, ParsedRule[]>): string {
    let toc = '## Table of Contents\n\n';

    for (const [tag, rules] of groupedByTag.entries()) {
      const anchor = tag.toLowerCase().replace(/\s+/g, '-');
      toc += `- [${this.capitalize(tag)}](#${anchor}) (${rules.length} rules)\n`;
    }

    toc += '\n---\n\n';

    return toc;
  }

  /**
   * æŒ‰æ ‡ç­¾æ ¼å¼åŒ–è§„åˆ™
   */
  private formatRulesByTag(groupedByTag: Map<string, ParsedRule[]>): string {
    let content = '';

    for (const [tag, rules] of groupedByTag.entries()) {
      content += `## ${this.capitalize(tag)}\n\n`;

      for (const rule of rules) {
        content += `### ${rule.title}\n\n`;

        // æ·»åŠ å…ƒæ•°æ®
        const metadata = this.formatMetadata(rule);
        if (metadata) {
          content += `${metadata}\n\n`;
        }

        // æ·»åŠ è§„åˆ™å†…å®¹
        content += `${rule.content}\n\n`;
      }

      content += '---\n\n';
    }

    return content;
  }

  /**
   * æ ¼å¼åŒ–å…ƒæ•°æ®
   */
  private formatMetadata(rule: ParsedRule): string {
    const parts: string[] = [];

    if (rule.metadata.priority) {
      const emoji = this.getPriorityEmoji(rule.metadata.priority);
      parts.push(`${emoji} **Priority:** ${rule.metadata.priority}`);
    }

    if (rule.metadata.author) {
      parts.push(`ğŸ‘¤ **Author:** ${rule.metadata.author}`);
    }

    if (rule.metadata.version) {
      parts.push(`ğŸ“Œ **Version:** ${rule.metadata.version}`);
    }

    if (rule.metadata.tags && rule.metadata.tags.length > 0) {
      parts.push(`ğŸ·ï¸ **Tags:** ${rule.metadata.tags.join(', ')}`);
    }

    return parts.length > 0 ? parts.join(' | ') : '';
  }

  /**
   * è·å–ä¼˜å…ˆçº§å¯¹åº”çš„ emoji
   */
  private getPriorityEmoji(priority: string): string {
    const emojiMap: Record<string, string> = {
      high: 'ğŸ”´',
      medium: 'ğŸŸ¡',
      low: 'ğŸŸ¢',
    };
    return emojiMap[priority] || 'âšª';
  }

  /**
   * é¦–å­—æ¯å¤§å†™
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * ç”Ÿæˆç©ºé…ç½®
   */
  private generateEmptyConfig(): string {
    return (
      this.generateMetadata(0) +
      '# GitHub Copilot Instructions\n\n' +
      '> No rules configured yet.\n'
    );
  }

  /**
   * éªŒè¯é…ç½®æ–‡ä»¶
   */
  validate(content: string): boolean {
    if (!super.validate(content)) {
      return false;
    }

    // æ£€æŸ¥æ˜¯å¦åŒ…å«æ ‡é¢˜
    return content.includes('# ') || content.includes('## ');
  }

  /**
   * è·å–æ–‡ä»¶è·¯å¾„
   */
  getFilePath(): string {
    return '.github/.copilot-instructions.md';
  }
}
