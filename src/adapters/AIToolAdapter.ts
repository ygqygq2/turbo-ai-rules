/**
 * AI 工具适配器接口
 * 定义不同 AI 工具的配置生成规范
 */

import type { ParsedRule } from '../types/rules';

/**
 * 生成的配置信息
 */
export interface GeneratedConfig {
  /** 输出文件路径（相对于工作区根目录） */
  filePath: string;
  /** 生成的内容 */
  content: string;
  /** 生成时间 */
  generatedAt: Date;
  /** 使用的规则数量 */
  ruleCount: number;
}

/**
 * AI 工具适配器接口
 */
export interface AIToolAdapter {
  /** 适配器名称 */
  readonly name: string;

  /** 是否启用 */
  readonly enabled: boolean;

  /**
   * 生成配置文件内容
   * @param rules 规则列表
   * @returns 生成的配置信息
   */
  generate(rules: ParsedRule[]): Promise<GeneratedConfig>;

  /**
   * 验证生成的配置
   * @param content 配置内容
   * @returns 是否有效
   */
  validate(content: string): boolean;

  /**
   * 获取配置文件路径
   * @returns 配置文件相对路径
   */
  getFilePath(): string;
}

/**
 * 抽象基类，提供通用功能
 */
export abstract class BaseAdapter implements AIToolAdapter {
  abstract readonly name: string;
  abstract readonly enabled: boolean;

  abstract generate(rules: ParsedRule[]): Promise<GeneratedConfig>;
  abstract getFilePath(): string;

  /**
   * 默认验证：检查内容是否非空
   */
  validate(content: string): boolean {
    return content.trim().length > 0;
  }

  /**
   * 格式化规则内容（通用工具方法）
   * @param rules 规则列表
   * @returns 格式化后的内容
   */
  protected formatRules(rules: ParsedRule[]): string {
    return rules
      .map((rule) => {
        const header = `# ${rule.title}\n`;
        const content = rule.content;
        const separator = '\n---\n\n';
        return header + content + separator;
      })
      .join('');
  }

  /**
   * 生成元数据注释
   * @param ruleCount 规则数量
   * @returns 元数据注释
   */
  protected generateMetadata(ruleCount: number): string {
    const timestamp = new Date().toISOString();
    return (
      `<!-- Generated by Turbo AI Rules at ${timestamp} -->\n` +
      `<!-- Total rules: ${ruleCount} -->\n\n`
    );
  }

  /**
   * 生成统一的文件头部（元数据 + 标题 + 说明）
   * @param toolName AI 工具名称
   * @param ruleCount 规则数量
   * @returns 文件头部内容
   */
  protected generateFileHeader(toolName: string, ruleCount: number): string {
    let header = '';
    header += this.generateMetadata(ruleCount);
    header += `# AI Coding Rules for ${toolName}\n\n`;
    header += '> This file is automatically generated by Turbo AI Rules extension.\n';
    header += '> Do not edit manually - changes will be overwritten on next sync.\n\n';
    return header;
  }

  /**
   * 生成目录（Table of Contents）
   * @param rules 规则列表
   * @returns 目录内容
   */
  protected generateTableOfContents(rules: ParsedRule[]): string {
    if (!rules || rules.length === 0) return '';

    let toc = '## Table of Contents\n\n';

    for (const rule of rules) {
      const anchor = this.createAnchor(rule.title);
      toc += `- [${rule.title}](#${anchor})\n`;
    }

    toc += '\n---\n\n';
    return toc;
  }

  /**
   * 创建标题锚点
   * @param title 标题
   * @returns 锚点字符串
   */
  protected createAnchor(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fa5]+/g, '-')
      .replace(/(^-|-$)/g, '');
  }

  /**
   * 格式化规则元数据为单行
   * @param rule 规则
   * @returns 元数据字符串
   */
  protected formatRuleMetadata(rule: ParsedRule): string {
    const metaParts: string[] = [];
    if (rule.metadata.priority) metaParts.push(`**Priority:** ${rule.metadata.priority}`);
    if (rule.metadata.tags && rule.metadata.tags.length > 0)
      metaParts.push(`**Tags:** ${rule.metadata.tags.join(', ')}`);
    if (rule.sourceId) metaParts.push(`**Source:** ${rule.sourceId}`);
    if (rule.filePath) metaParts.push(`**File:** ${rule.filePath}`);
    if (rule.metadata.author) metaParts.push(`**Author:** ${rule.metadata.author}`);
    if (rule.metadata.version) metaParts.push(`**Version:** ${rule.metadata.version}`);

    return metaParts.length > 0 ? metaParts.join(' | ') : '';
  }

  /**
   * 按优先级排序规则
   * @param rules 规则列表
   * @returns 排序后的规则列表
   */
  protected sortByPriority(rules: ParsedRule[]): ParsedRule[] {
    const priorityOrder = { high: 3, medium: 2, low: 1 };

    return [...rules].sort((a, b) => {
      const aPriority = a.metadata.priority || 'low';
      const bPriority = b.metadata.priority || 'low';
      return priorityOrder[bPriority] - priorityOrder[aPriority];
    });
  }

  /**
   * 按标签分组规则
   * @param rules 规则列表
   * @returns 按标签分组的 Map
   */
  protected groupByTag(rules: ParsedRule[]): Map<string, ParsedRule[]> {
    const groups = new Map<string, ParsedRule[]>();

    for (const rule of rules) {
      const tags = rule.metadata.tags || ['general'];
      for (const tag of tags) {
        const existing = groups.get(tag) || [];
        existing.push(rule);
        groups.set(tag, existing);
      }
    }

    return groups;
  }
}
