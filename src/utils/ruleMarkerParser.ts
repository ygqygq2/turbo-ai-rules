/**
 * 规则标记解析器
 * 解析带标记的配置文件，提取规则源区块和规则区块
 */

import type {
  ParsedMarkedFile,
  RuleBlock,
  SourceBlock,
  UserContentBlock,
} from '../types/ruleMarker';

/**
 * 标记正则表达式
 */
const REGEX = {
  /** 匹配 BEGIN_SOURCE 标记及其属性 */
  BEGIN_SOURCE: /<!--\s*BEGIN_SOURCE\s+source="([^"]+)"\s+count="(\d+)"\s*-->/,
  /** 匹配 END_SOURCE 标记 */
  END_SOURCE: /<!--\s*END_SOURCE\s+source="([^"]+)"\s*-->/,
  /** 匹配 BEGIN_RULE 标记及其属性 */
  BEGIN_RULE: /<!--\s*BEGIN_RULE\s+source="([^"]+)"\s+id="([^"]+)"(?:\s+priority="([^"]+)")?\s*-->/,
  /** 匹配 END_RULE 标记 */
  END_RULE: /<!--\s*END_RULE\s*-->/,
  /** 匹配 BEGIN_USER_CONTENT 标记 */
  BEGIN_USER_CONTENT: /<!--\s*BEGIN_USER_CONTENT\s*-->/,
  /** 匹配 END_USER_CONTENT 标记 */
  END_USER_CONTENT: /<!--\s*END_USER_CONTENT\s*-->/,
  /** 匹配生成器签名 */
  GENERATOR_SIGNATURE: /<!--\s*Generated by Turbo AI Rules/,
};

/**
 * @description 解析带标记的配置文件
 * @return {ParsedMarkedFile}
 * @param content {string} 文件内容
 */
export function parseMarkedFile(content: string): ParsedMarkedFile {
  const lines = content.split('\n');
  const sourceBlocks: SourceBlock[] = [];
  let userContent: UserContentBlock | null = null;
  let header = '';
  let hasValidMarkers = false;

  // 检查是否有生成器签名
  if (REGEX.GENERATOR_SIGNATURE.test(content)) {
    hasValidMarkers = true;
  }

  // 查找第一个 SOURCE 区块的位置
  let firstSourceStart = -1;
  for (let i = 0; i < lines.length; i++) {
    if (REGEX.BEGIN_SOURCE.test(lines[i])) {
      firstSourceStart = i;
      break;
    }
  }

  // 提取头部内容
  if (firstSourceStart > 0) {
    header = lines.slice(0, firstSourceStart).join('\n');
  } else if (firstSourceStart === -1) {
    // 没有 SOURCE 标记，整个文件作为头部
    header = content;
  }

  // 解析 SOURCE 区块
  let i = firstSourceStart;
  while (i >= 0 && i < lines.length) {
    const sourceMatch = lines[i].match(REGEX.BEGIN_SOURCE);
    if (sourceMatch) {
      const sourceBlock = parseSourceBlock(lines, i, sourceMatch[1], parseInt(sourceMatch[2], 10));
      if (sourceBlock) {
        sourceBlocks.push(sourceBlock);
        hasValidMarkers = true;
        i = sourceBlock.endLine + 1;
        continue;
      }
    }

    // 检查用户内容区块
    if (REGEX.BEGIN_USER_CONTENT.test(lines[i])) {
      userContent = parseUserContentBlock(lines, i);
      if (userContent) {
        i = userContent.endLine + 1;
        continue;
      }
    }

    i++;
  }

  return {
    header,
    sourceBlocks,
    userContent,
    hasValidMarkers,
  };
}

/**
 * @description 解析单个规则源区块
 * @return {SourceBlock | null}
 * @param lines {string[]} 所有行
 * @param startLine {number} 开始行号
 * @param sourceId {string} 规则源 ID
 * @param count {number} 规则数量
 */
function parseSourceBlock(
  lines: string[],
  startLine: number,
  sourceId: string,
  count: number,
): SourceBlock | null {
  const rules: RuleBlock[] = [];
  let endLine = startLine;

  // 查找 END_SOURCE 标记
  for (let i = startLine + 1; i < lines.length; i++) {
    const endMatch = lines[i].match(REGEX.END_SOURCE);
    if (endMatch && endMatch[1] === sourceId) {
      endLine = i;
      break;
    }

    // 解析内部的 RULE 区块
    const ruleMatch = lines[i].match(REGEX.BEGIN_RULE);
    if (ruleMatch && ruleMatch[1] === sourceId) {
      const ruleBlock = parseRuleBlock(lines, i, ruleMatch[1], ruleMatch[2], ruleMatch[3]);
      if (ruleBlock) {
        rules.push(ruleBlock);
      }
    }
  }

  const rawContent = lines.slice(startLine, endLine + 1).join('\n');

  return {
    sourceId,
    count,
    startLine,
    endLine,
    rules,
    rawContent,
  };
}

/**
 * @description 解析单条规则区块
 * @return {RuleBlock | null}
 * @param lines {string[]} 所有行
 * @param startLine {number} 开始行号
 * @param sourceId {string} 规则源 ID
 * @param ruleId {string} 规则 ID
 * @param priority {string | undefined} 优先级
 */
function parseRuleBlock(
  lines: string[],
  startLine: number,
  sourceId: string,
  ruleId: string,
  priority?: string,
): RuleBlock | null {
  let endLine = startLine;

  // 查找 END_RULE 标记
  for (let i = startLine + 1; i < lines.length; i++) {
    if (REGEX.END_RULE.test(lines[i])) {
      endLine = i;
      break;
    }
  }

  const rawContent = lines.slice(startLine, endLine + 1).join('\n');
  // 提取不含标记的内容
  const content = lines.slice(startLine + 1, endLine).join('\n');

  return {
    sourceId,
    ruleId,
    priority,
    startLine,
    endLine,
    rawContent,
    content,
  };
}

/**
 * @description 解析用户内容区块
 * @return {UserContentBlock | null}
 * @param lines {string[]} 所有行
 * @param startLine {number} 开始行号
 */
function parseUserContentBlock(lines: string[], startLine: number): UserContentBlock | null {
  let endLine = startLine;

  // 查找 END_USER_CONTENT 标记
  for (let i = startLine + 1; i < lines.length; i++) {
    if (REGEX.END_USER_CONTENT.test(lines[i])) {
      endLine = i;
      break;
    }
  }

  const rawContent = lines.slice(startLine, endLine + 1).join('\n');
  const content = lines.slice(startLine + 1, endLine).join('\n');

  return {
    startLine,
    endLine,
    rawContent,
    content,
  };
}

/**
 * @description 检查文件是否支持部分更新
 * @return {boolean}
 * @param content {string} 文件内容
 */
export function supportsPartialUpdate(content: string): boolean {
  return REGEX.GENERATOR_SIGNATURE.test(content) && REGEX.BEGIN_SOURCE.test(content);
}

/**
 * @description 获取文件中的所有规则源 ID
 * @return {string[]}
 * @param content {string} 文件内容
 */
export function extractSourceIds(content: string): string[] {
  const parsed = parseMarkedFile(content);
  return parsed.sourceBlocks.map((block) => block.sourceId);
}
