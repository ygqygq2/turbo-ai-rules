/**
 * User Rules Protection Utilities
 *
 * Provides functions to protect user-defined rules from being overwritten
 * during sync operations. Supports two modes:
 * 1. Directory mode: File prefix avoidance (80000-99999 range)
 * 2. Single-file mode: Block marker protection
 */

import * as path from 'path';
import * as vscode from 'vscode';

/**
 * Block marker constants for single-file mode
 */
export const BLOCK_MARKERS = {
  begin: '<!-- TURBO-AI-RULES:BEGIN -->',
  end: '<!-- TURBO-AI-RULES:END -->',
} as const;

/**
 * Default prefix ranges for directory mode
 */
export const PREFIX_RANGES = {
  AUTO_MIN: 0,
  AUTO_MAX: 79999,
  USER_MIN: 80000,
  USER_MAX: 99999,
} as const;

/**
 * Configuration for user rules protection
 */
export interface UserRulesProtectionConfig {
  /**
   * Enable user rules protection
   */
  enabled: boolean;

  /**
   * User-defined prefix range (for directory mode)
   * @default { min: 800, max: 999 }
   */
  userPrefixRange?: {
    min: number;
    max: number;
  };

  /**
   * Custom block markers (for single-file mode)
   */
  blockMarkers?: {
    begin: string;
    end: string;
  };
}

/**
 * Extract numeric prefix from filename
 * @example
 * extractPrefix("00001-overview.md") => 1
 * extractPrefix("50000-typescript.mdc") => 50000
 * extractPrefix("no-prefix.md") => null
 */
export function extractPrefix(filename: string): number | null {
  const match = filename.match(/^(\d+)-/);
  return match ? parseInt(match[1], 10) : null;
}

/**
 * Check if a file is in the user-defined range (directory mode)
 * @param filename - The filename to check
 * @param config - Protection configuration
 * @returns true if the file is user-defined
 *
 * @example
 * isUserDefinedFile("85000-my-rules.md") => true
 * isUserDefinedFile("20000-auto.md") => false
 * isUserDefinedFile("no-prefix.md") => false (conservative: treat as user file)
 */
export function isUserDefinedFile(filename: string, config: UserRulesProtectionConfig): boolean {
  if (!config.enabled) {
    return false;
  }

  const prefix = extractPrefix(filename);

  // 如果没有前缀，不在保护范围内（视为自动生成文件）
  if (prefix === null) {
    return false;
  }

  const range = config.userPrefixRange || {
    min: PREFIX_RANGES.USER_MIN,
    max: PREFIX_RANGES.USER_MAX,
  };

  return prefix >= range.min && prefix <= range.max;
}

/**
 * Check if a file is in the auto-generated range (directory mode)
 * @param filename - The filename to check
 * @param config - Protection configuration
 * @returns true if the file is auto-generated (safe to overwrite)
 */
export function isAutoGeneratedFile(filename: string, config: UserRulesProtectionConfig): boolean {
  if (!config.enabled) {
    return true; // If protection disabled, treat all as auto-generated
  }

  const prefix = extractPrefix(filename);

  // 如果没有前缀，视为自动生成文件（可以覆盖）
  if (prefix === null) {
    return true;
  }

  return prefix >= PREFIX_RANGES.AUTO_MIN && prefix <= PREFIX_RANGES.AUTO_MAX;
}

/**
 * Filter out user-defined files from a file list
 * @param files - List of file paths
 * @param config - Protection configuration
 * @returns Array of auto-generated files only
 */
export function filterAutoGeneratedFiles(
  files: string[],
  config: UserRulesProtectionConfig,
): string[] {
  return files.filter((file) => {
    const filename = path.basename(file);
    return isAutoGeneratedFile(filename, config);
  });
}

/**
 * Extract user content from a file with block markers (single-file mode)
 * @param content - The file content
 * @param config - Protection configuration
 * @returns Object with autoContent (inside blocks) and userContent (outside blocks)
 *
 * @example
 * const { userContent } = extractUserContent(fileContent);
 * // Returns content outside <!-- TURBO-AI-RULES:BEGIN/END --> blocks
 */
export function extractUserContent(
  content: string,
  config: UserRulesProtectionConfig,
): { autoContent: string; userContent: string } {
  const markers = config.blockMarkers || BLOCK_MARKERS;

  // Escape special regex characters in markers
  const beginMarker = markers.begin.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const endMarker = markers.end.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  // Match everything between BEGIN and END markers (including markers)
  const blockRegex = new RegExp(`${beginMarker}[\\s\\S]*?${endMarker}`, 'g');

  // Extract auto-generated content (inside blocks)
  const autoMatches = content.match(blockRegex) || [];
  const autoContent = autoMatches.join('\n\n');

  // Extract user content (outside blocks)
  const userContent = content.replace(blockRegex, '').trim();

  return { autoContent, userContent };
}

/**
 * Merge auto-generated content with user content (single-file mode)
 * @param autoContent - Auto-generated content (will be wrapped in block markers)
 * @param userContent - User-defined content
 * @param config - Protection configuration
 * @returns Merged content with block markers
 */
export function mergeContent(
  autoContent: string,
  userContent: string,
  config: UserRulesProtectionConfig,
): string {
  const markers = config.blockMarkers || BLOCK_MARKERS;

  // Wrap auto-generated content with markers and metadata
  const wrappedAutoContent = [
    markers.begin,
    `<!-- Generated by Turbo AI Rules at ${new Date().toISOString()} -->`,
    `<!-- ⚠️  WARNING: Auto-generated content - Will be overwritten on sync -->`,
    `<!-- ⚠️  警告：自动生成内容 - 同步时会被覆盖 -->`,
    '',
    autoContent,
    '',
    markers.end,
  ].join('\n');

  // If user content exists, append it after the auto-generated block
  if (userContent) {
    return `${wrappedAutoContent}\n\n${userContent}`;
  }

  // No user content: just return the wrapped auto-generated content
  return wrappedAutoContent;
}

/**
 * Detect if there are conflicting filenames (directory mode)
 * @param existingFiles - List of existing files in the directory
 * @param newFiles - List of new files to be generated
 * @param config - Protection configuration
 * @returns Array of conflicting filenames
 */
export function detectConflicts(
  existingFiles: string[],
  newFiles: string[],
  config: UserRulesProtectionConfig,
): string[] {
  if (!config.enabled) {
    return [];
  }

  const conflicts: string[] = [];
  const existingBasenames = new Set(existingFiles.map((f) => path.basename(f)));

  for (const newFile of newFiles) {
    const basename = path.basename(newFile);
    if (existingBasenames.has(basename)) {
      const prefix = extractPrefix(basename);
      // Only report conflicts if the existing file is in user range
      if (prefix !== null) {
        const range = config.userPrefixRange || {
          min: PREFIX_RANGES.USER_MIN,
          max: PREFIX_RANGES.USER_MAX,
        };
        if (prefix >= range.min && prefix <= range.max) {
          conflicts.push(basename);
        }
      }
    }
  }

  return conflicts;
}

/**
 * Show warning dialog for file conflicts
 * @param conflicts - Array of conflicting filenames
 * @returns User's choice
 */
export async function showConflictWarning(
  conflicts: string[],
): Promise<'skip' | 'rename' | 'cancel'> {
  const message = vscode.l10n.t(
    'Found {0} file(s) in user-defined range (80000-99999). These files will be skipped to avoid overwriting your custom rules.',
    conflicts.length,
  );

  const detail = vscode.l10n.t(
    'Conflicting files:\n{0}\n\nRecommendation: Keep these files or rename auto-generated files.',
    conflicts.join('\n'),
  );

  const skip = vscode.l10n.t('Skip Conflicts');
  const viewGuide = vscode.l10n.t('View Guide');
  const cancel = vscode.l10n.t('Cancel');

  const choice = await vscode.window.showWarningMessage(
    message,
    { modal: true, detail },
    skip,
    viewGuide,
    cancel,
  );

  if (choice === viewGuide) {
    vscode.env.openExternal(
      vscode.Uri.parse('https://github.com/ygqygq2/turbo-ai-rules#user-defined-rules'),
    );
    return 'cancel';
  }

  return choice === skip ? 'skip' : 'cancel';
}

/**
 * Generate suggested filename to avoid conflicts
 * @param originalFilename - Original filename
 * @param existingFiles - List of existing files
 * @returns Suggested filename in auto-generated range
 *
 * @example
 * suggestAlternativeFilename("85000-rules.md", [...]) => "75000-rules.md"
 */
export function suggestAlternativeFilename(
  originalFilename: string,
  existingFiles: string[],
): string {
  const prefix = extractPrefix(originalFilename);
  if (prefix === null) {
    return originalFilename;
  }

  // If in user range, suggest a prefix in auto range
  if (prefix >= PREFIX_RANGES.USER_MIN && prefix <= PREFIX_RANGES.USER_MAX) {
    const baseFilename = originalFilename.replace(/^\d+-/, '');
    const existingPrefixes = new Set(
      existingFiles
        .map((f) => extractPrefix(path.basename(f)))
        .filter((p): p is number => p !== null && p <= PREFIX_RANGES.AUTO_MAX),
    );

    // Find next available prefix in auto range (backwards from 79999)
    for (let i = PREFIX_RANGES.AUTO_MAX; i >= PREFIX_RANGES.AUTO_MIN; i--) {
      if (!existingPrefixes.has(i)) {
        return `${String(i).padStart(5, '0')}-${baseFilename}`;
      }
    }
  }

  return originalFilename;
}
