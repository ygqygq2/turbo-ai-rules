<!-- TURBO-AI-RULES:BEGIN -->
<!-- Generated by Turbo AI Rules at 2025-12-23T02:50:10.727Z -->
<!-- ⚠️  WARNING: Auto-generated content - Will be overwritten on sync -->
<!-- ⚠️  警告：自动生成内容 - 同步时会被覆盖 -->

<!-- Generated by Turbo AI Rules at 2025-12-23T02:50:10.723Z -->
<!-- Total rules: 2 -->

# AI Coding Rules for Windsurf

> This file is automatically generated by Turbo AI Rules extension.
> Do not edit manually - changes will be overwritten on next sync.

> **Windsurf**: Codeium AI IDE with advanced context understanding
> **Website**: https://codeium.com/windsurf

## Table of Contents

- [TypeScript Development Skills](#typescript-development-skills)
- [Debugging Skills](#debugging-skills)

---

# TypeScript Development Skills

## Core Competencies

### 1. Type System Mastery

```typescript
// Union and Intersection Types
type Status = 'pending' | 'approved' | 'rejected';
type User = { name: string } & { id: number };

// Generics
function identity<T>(value: T): T {
  return value;
}

// Utility Types
type Partial<T> = { [P in keyof T]?: T[P] };
type ReadonlyDeep<T> = { readonly [P in keyof T]: ReadonlyDeep<T[P]> };

// Conditional Types
type IsString<T> = T extends string ? true : false;

// Mapped Types
type Optional<T> = {
  [P in keyof T]?: T[P];
};
```

### 2. Advanced Patterns

#### Discriminated Unions

```typescript
type Success = {
  status: 'success';
  data: any;
};

type Error = {
  status: 'error';
  message: string;
};

type Result = Success | Error;

function handleResult(result: Result) {
  if (result.status === 'success') {
    // TypeScript knows result is Success here
    console.log(result.data);
  } else {
    // TypeScript knows result is Error here
    console.error(result.message);
  }
}
```

#### Type Guards

```typescript
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function processValue(value: unknown) {
  if (isString(value)) {
    // value is string here
    return value.toUpperCase();
  }
  return null;
}
```

### 3. Async Patterns

```typescript
// Promise with proper error handling
async function fetchData<T>(url: string): Promise<T> {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return (await response.json()) as T;
  } catch (error) {
    console.error('Fetch failed:', error);
    throw error;
  }
}

// Concurrent requests
async function fetchMultiple<T>(urls: string[]): Promise<T[]> {
  const results = await Promise.all(urls.map((url) => fetchData<T>(url)));
  return results;
}
```

### 4. Module Organization

```typescript
// Use barrel exports (index.ts)
export * from './types';
export * from './utils';
export { default as MyComponent } from './MyComponent';

// Named exports preferred over default
export class DataService {
  async getData(): Promise<Data> {
    // implementation
  }
}

// Use path aliases (@/ for src/)
import { DataService } from '@/services/DataService';
```

### 5. Configuration Best Practices

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

## Testing with TypeScript

### Unit Tests

```typescript
import { describe, it, expect, beforeEach } from 'vitest';

describe('DataService', () => {
  let service: DataService;

  beforeEach(() => {
    service = new DataService();
  });

  it('should fetch data successfully', async () => {
    const data = await service.getData();
    expect(data).toBeDefined();
    expect(data.items).toHaveLength(0);
  });

  it('should handle errors gracefully', async () => {
    await expect(service.getData()).rejects.toThrow('Network error');
  });
});
```

### Type Testing

```typescript
import { expectType } from 'tsd';

// Test that types are correct
expectType<string>(identity('hello'));
expectType<number>(identity(42));
```

## Performance Tips

1. **Use const assertions**: `const data = { x: 10 } as const;`
2. **Avoid excessive type checks**: Trust TypeScript, don't validate types at runtime
3. **Use incremental compilation**: Enable `incremental: true` in tsconfig
4. **Optimize imports**: Use direct imports instead of barrel exports in large projects
5. **Enable project references**: For monorepo projects

## Common Pitfalls

1. **Any type abuse**: Use `unknown` instead of `any` when type is truly unknown
2. **Non-null assertions**: Avoid `!` operator, use proper null checks
3. **Type assertions**: Use sparingly, prefer type guards
4. **Enum limitations**: Consider string literal unions instead
5. **Object.keys() type**: Returns `string[]`, not `keyof T`

## Tools and Ecosystem

- **ESLint**: Use @typescript-eslint for linting
- **Prettier**: Format code consistently
- **ts-node**: Run TypeScript directly
- **tsx**: Fast TypeScript execution
- **Vitest**: Unit testing framework with TypeScript support

## Resources

- TypeScript Handbook: Official documentation
- Type Challenges: Practice advanced types
- DefinitelyTyped: Type definitions repository

---

# Debugging Skills

## Systematic Approach

### 1. Reproduce the Issue

- Document exact steps to reproduce
- Identify environmental factors (OS, browser, dependencies)
- Create minimal reproduction case
- Verify issue exists in clean environment

### 2. Gather Information

```typescript
// Add strategic logging
console.log('Input:', input);
console.log('State before:', state);
console.log('State after:', newState);
console.log('Stack trace:', new Error().stack);

// Use debugger statements
function problematicFunction(data: any) {
  debugger; // Execution will pause here
  return processData(data);
}
```

### 3. Form Hypothesis

- What could cause this behavior?
- What changed recently?
- What assumptions am I making?
- What are the data flows?

### 4. Test and Validate

- Test one change at a time
- Use binary search for regression (git bisect)
- Validate assumptions with assertions
- Document findings

## Debugging Tools

### Browser DevTools

```javascript
// Console API
console.log('Basic logging');
console.table([{ name: 'Alice', age: 30 }]);
console.time('operation');
// ... code ...
console.timeEnd('operation');
console.trace('Call stack');

// Breakpoints
// - Line breakpoints
// - Conditional breakpoints: `x > 100`
// - Logpoints: Non-breaking console.log

// Network tab
// - Check request/response
// - Monitor timing
// - Inspect headers and payloads
```

### VS Code Debugger

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug TypeScript",
      "program": "${workspaceFolder}/src/index.ts",
      "preLaunchTask": "npm: build",
      "sourceMaps": true,
      "outFiles": ["${workspaceFolder}/dist/**/*.js"]
    }
  ]
}
```

### Command Line Tools

```bash
# Node.js debugging
node --inspect-brk index.js

# Memory profiling
node --inspect --heap-prof index.js

# Python debugging
python -m pdb script.py

# Git bisect for regression
git bisect start
git bisect bad HEAD
git bisect good v1.0.0
# Test each commit
git bisect good/bad
git bisect reset
```

## Common Debugging Scenarios

### Memory Leaks

```typescript
// Check for detached DOM nodes
// - Use Chrome DevTools Memory profiler
// - Take heap snapshots
// - Compare snapshots to find retained objects

// Common causes:
// 1. Event listeners not removed
window.addEventListener('resize', handler);
// Later: window.removeEventListener('resize', handler);

// 2. Timers not cleared
const timerId = setInterval(fn, 1000);
// Later: clearInterval(timerId);

// 3. Closures holding references
function createHandler() {
  const largeData = new Array(1000000);
  return () => {
    // largeData is kept in memory
    console.log(largeData.length);
  };
}
```

### Race Conditions

```typescript
// Add synchronization
let isProcessing = false;

async function handleClick() {
  if (isProcessing) {
    console.warn('Already processing');
    return;
  }

  isProcessing = true;
  try {
    await processData();
  } finally {
    isProcessing = false;
  }
}

// Use Promise.all for concurrent operations
await Promise.all([fetchUserData(), fetchSettings(), fetchPermissions()]);
```

### Type Errors

```typescript
// Add runtime validation
function processUser(user: unknown) {
  if (!isUser(user)) {
    throw new TypeError('Invalid user object');
  }
  // user is User type here
  return user.name;
}

function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'name' in obj &&
    typeof obj.name === 'string'
  );
}
```

## Best Practices

### 1. Write Debuggable Code

```typescript
// Good: Clear, debuggable
function processOrders(orders: Order[]): ProcessedOrder[] {
  const validOrders = validateOrders(orders);
  const enrichedOrders = enrichOrders(validOrders);
  const sortedOrders = sortOrders(enrichedOrders);
  return sortedOrders;
}

// Bad: Hard to debug
function processOrders(orders: Order[]): ProcessedOrder[] {
  return sortOrders(enrichOrders(validateOrders(orders)));
}
```

### 2. Add Assertions

```typescript
function divide(a: number, b: number): number {
  console.assert(b !== 0, 'Division by zero');
  console.assert(isFinite(a) && isFinite(b), 'Invalid numbers');
  return a / b;
}
```

### 3. Use Error Boundaries

```typescript
// React error boundary
class ErrorBoundary extends React.Component {
  componentDidCatch(error: Error, info: any) {
    console.error('Error caught:', error);
    console.error('Component stack:', info.componentStack);
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }
    return this.props.children;
  }
}
```

### 4. Structured Logging

```typescript
import { Logger } from '@ygqygq2/vscode-log';

const logger = new Logger('MyModule');

function processData(data: any) {
  logger.info('Processing started', {
    dataSize: data.length,
    timestamp: Date.now(),
  });

  try {
    const result = transform(data);
    logger.info('Processing completed', {
      resultSize: result.length,
    });
    return result;
  } catch (error) {
    logger.error('Processing failed', {
      error: error.message,
      stack: error.stack,
      data: JSON.stringify(data).slice(0, 100),
    });
    throw error;
  }
}
```

## Advanced Techniques

### Performance Debugging

```typescript
// Use Performance API
performance.mark('start-operation');
await expensiveOperation();
performance.mark('end-operation');
performance.measure('operation-time', 'start-operation', 'end-operation');

const measures = performance.getEntriesByType('measure');
console.log('Duration:', measures[0].duration);
```

### Network Debugging

```typescript
// Add request interceptor
async function fetchWithLogging(url: string, options?: RequestInit) {
  const requestId = Math.random().toString(36);
  console.log(`[${requestId}] Request:`, url, options);

  const start = performance.now();
  try {
    const response = await fetch(url, options);
    const duration = performance.now() - start;
    console.log(`[${requestId}] Response:`, {
      status: response.status,
      duration: `${duration}ms`,
    });
    return response;
  } catch (error) {
    console.error(`[${requestId}] Error:`, error);
    throw error;
  }
}
```

## Resources

- Chrome DevTools Documentation
- VS Code Debugging Guide
- Node.js Debugging Guide
- Performance profiling tools

<!-- TURBO-AI-RULES:END -->